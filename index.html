import express from 'express';
import cors from 'cors';
import { GoogleGenerativeAI } from '@google/generative-ai';
import { crearPrompt, limpiarTexto, detectarTema } from './prompt.js';

const app = express();
const PORT = process.env.PORT || 10000;

app.use(cors());
app.use(express.json());
app.use(express.static('.')); 

// üîë API Gemini
const API_KEY = 'AIzaSyCuRbKPJ5xFrq3eDFgltITbZqqeHph8LFg';
const genAI = new GoogleGenerativeAI(API_KEY);
const model = genAI.getGenerativeModel({ model: 'gemini-1.5-flash' });

// Almacenamiento en memoria del historial de conversaciones
const conversaciones = {};

// Funci√≥n para obtener o crear una conversaci√≥n
function obtenerConversacion(usuarioId) {
    if (!conversaciones[usuarioId]) {
        conversaciones[usuarioId] = {
            historial: [],
            temaActual: null,
            pasoActual: null
        };
    }
    return conversaciones[usuarioId];
}

// Funci√≥n para generar IDs √∫nicos
function generarIdUnico() {
    return Date.now().toString(36) + Math.random().toString(36).substr(2);
}

/**
 * üßπ Limpieza de texto para que el tutor no lea s√≠mbolos raros
 */
function limpiarTextoServidor(texto) {
    return texto
        .replace(/\*\*(.*?)\*\*/g, '$1')
        .replace(/\*(.*?)\*/g, '$1')
        .replace(/^- /gm, '')
        .replace(/^>+/gm, '')
        .replace(/‚û°Ô∏è|‚Üí/g, ' sigue con ')
        .replace(/‚úÖ/g, ' correcto ')
        .replace(/üìù/g, ' nota ')
        .replace(/üí°/g, ' idea ')
        .replace(/üî•/g, ' importante ')
        .replace(/üòä|üëç|üò¢|ü§î|üí°|‚úÖ|‚ùå|üìù/g, (match) => match)
        .replace(/[^\p{L}\p{N}\p{P}\p{Z}\nüòäüëçüò¢ü§îüí°‚úÖ‚ùåüìù]/gu, "")
        .replace(/\s+/g, ' ')
        .trim();
}

// Funci√≥n para crear prompt con historial
function crearPromptConHistorial(conversacion, textoUsuario, tieneImagen) {
    // Construir el historial de la conversaci√≥n
    let historialFormateado = '';
    if (conversacion.historial.length > 0) {
        historialFormateado = conversacion.historial.map(entry => {
            return `${entry.rol === 'estudiante' ? 'Estudiante' : 'Tutor'}: ${entry.mensaje}`;
        }).join('\n\n');
    }
    
    return `
Eres MatyMat-01, un tutor de matem√°ticas en Bolivia con 15 a√±os de experiencia.
Habla de forma natural, clara y amigable, como un profesor de secundaria.
No leas s√≠mbolos de formato como asteriscos o flechas, solo explica de manera sencilla.

Historial de la conversaci√≥n:
${historialFormateado}

Tema actual: ${conversacion.temaActual || 'No determinado'}

Nueva consulta del estudiante:
${tieneImagen ? 'Analiza la imagen y el texto.' : ''} ${textoUsuario}

Recuerda mantener el contexto de la conversaci√≥n anterior y continuar desde donde lo dejamos.
`.trim();
}

// === RUTA PRINCIPAL ===
app.post('/analizar', async (req, res) => {
    const { text, image, mimeType = 'image/jpeg', usuarioId } = req.body;
    
    if (!text || typeof text !== 'string') {
        return res.status(400).json({ error: 'Consulta inv√°lida o vac√≠a' });
    }
    
    // Obtener o crear la conversaci√≥n del usuario
    const conversacion = obtenerConversacion(usuarioId || 'default');
    
    try {
        let result;
        
        // Crear el prompt con el historial de conversaci√≥n
        const prompt = crearPromptConHistorial(conversacion, text, !!image);
        
        if (image && typeof image === 'string') {
            const imgData = { inlineData: { image, mimeType } };
            result = await model.generateContent([prompt, imgData]);
        } else {
            result = await model.generateContent(prompt);
        }
        
        const response = await result.response;
        let respuesta = response.text();
        
        // Limpiar la respuesta
        respuesta = limpiarTextoServidor(respuesta);
        
        // Actualizar el historial de la conversaci√≥n
        conversacion.historial.push({
            rol: 'estudiante',
            mensaje: text,
            timestamp: new Date()
        });
        
        conversacion.historial.push({
            rol: 'tutor',
            mensaje: respuesta,
            timestamp: new Date()
        });
        
        // Detectar el tema actual
        conversacion.temaActual = detectarTema(text);
        
        // Dividir la respuesta en pasos si contiene "Paso X:"
        let pasos = [];
        if (respuesta.includes('Paso')) {
            // Dividir por "Paso X:" pero manteniendo el encabezado
            const regex = /(Paso \d+:)/g;
            const partes = respuesta.split(regex);
            // Reconstruir cada paso
            for (let i = 1; i < partes.length; i += 2) {
                if (partes[i] && partes[i+1]) {
                    pasos.push(partes[i] + partes[i+1]);
                }
            }
            // Si no se pudo dividir correctamente, usar la respuesta completa
            if (pasos.length === 0) {
                pasos = [respuesta];
            }
        } else {
            pasos = [respuesta];
        }
        
        res.json({ 
            pasos,
            tema: conversacion.temaActual,
            conversationId: usuarioId || 'default'
        });
    } catch (error) {
        console.error('‚ùå Error con Gemini:', error.message || error);
        return res.status(500).json({ error: 'No pude procesar tu pregunta. Intenta de nuevo.' });
    }
});

app.listen(PORT, '0.0.0.0', () => {
    console.log(`‚úÖ Servidor en http://0.0.0.0:${PORT}`);
});



